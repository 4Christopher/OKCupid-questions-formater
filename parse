#!/usr/bin/env perl
use strict;
use warnings;
use autodie;
use feature qw(say);
use utf8;
binmode STDOUT, ':encoding(UTF-8)';
use JSON::DWIW;
use Term::ANSIColor;
## cpan JSON::DWIW Term::ANSIColor

my $file = "../data/questions.json";

#<<<
my @importance = (
    "Irrelevant",
    "A little important",
    "Somewhat important",
    "Very important",
    "Mandatory"
);
#>>>

my $json_parser = JSON::DWIW->new;
my $que         = $json_parser->from_json_file($file);
my $date        = $que->{date};
print "The data is from $date\n\n";

sub printIt {
    my $que_id = shift;
    my $pattern = shift;

    chomp( my $text = $que->{data}->{$que_id}->{text} );
    if (defined $pattern) {
        $text =~ /$pattern/ms;
        $text = ${^PREMATCH} . colored( ${^MATCH}, 'blue') . ${^POSTMATCH};
    }

    ## There are sometimes newlines at the end …
    if ( $que->{data}->{$que_id}->{isSkipped} ) { ## The question is skipped
        say "$que_id was skipped: $text";
    }
    else {
        my $imp = $que->{data}->{$que_id}->{importance};
        my $exp = $que->{data}->{$que_id}->{explanation};
        my $pub = $que->{data}->{$que_id}->{isPublic};
        my $visability;
        if ($pub) {
            $visability = "publicly";
        } else {
            $visability = "privately";
        }
        say "$text ($imp: $importance[$imp], $visability answered)";
        for my $ans_id ( sort { $a <=> $b } keys $que->{data}->{$que_id}->{answers} ) {
            my $ans_text  = $que->{data}->{$que_id}->{answers}->{$ans_id}->{text};
            my $my_ans    = $que->{data}->{$que_id}->{answers}->{$ans_id}->{isMine};
            my $match_ans = $que->{data}->{$que_id}->{answers}->{$ans_id}->{isMatch};
            if ($my_ans) {
                print color 'underline';
            }
            if ($match_ans) {
                print color 'green';
            }
            say "\t$ans_text" . color 'reset';
        }
    } ## end else [ if ( $que->{data}->{$que_id...})]
    print "\n";
} ## end sub printIt


print "Do you want to search for a question? ";
my $user_answer = <STDIN>;
if ($user_answer =~ /\A(?:y|j)/xmsi) {
    ## Building a query hash
    my %qQue;
    for my $que_id ( keys $que->{data} ) {
        chomp( my $text = $que->{data}->{$que_id}->{text} );
        ## There are sometimes newlines at the end …
        $qQue{$text} = $que_id;
    }

    say "You can use a perl regular expression to match against the questions.";
    while (1) {
	print "Please enter a pattern: ";
	chomp(my $pattern = <STDIN>);
	last if "$pattern" =~ /\A\s*\Z/;
        
	my @matches = eval { grep /$pattern/ms, keys %qQue };
	if ($@) {
		say "Your regular expresion failed";
		print "Error: $@";
		next;
	}

        my @que_id = map { $qQue{$_} } @matches;
	say "Matched " . @matches . " time(s):";
        if ( @matches > 20 ) {
            print "Do you really print all questions? ";
            my $user_answer = <STDIN>;
            next unless ($user_answer =~ /\A(?:y|j)/xmsi);
        }
        for my $que_id ( sort { $a <=> $b } @que_id ) {
            printIt $que_id, $pattern;
        }
    }
} else {
    for my $que_id ( sort { $a <=> $b } keys $que->{data} ) {
        printIt $que_id;
    }
}
